참고 Repository: https://github.com/WeareSoft/tech-interview

참고 블로그: https://brunch.co.kr/@toughrogrammer/17

# 📚 자료구조

자료구조 참고 링크: https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html

## 스택

- LIFO(후입선출): 가장 최근에 추가한 항목이 가장 먼저 나옴
- 사용 사례: 재귀 구현, 브라우저 뒤로가기, 실행취소, 수식 괄호 검사, 후위 표기법 계산

## 큐

- FIFO(선입선출): 가장 최근에 추가한 항목이 가장 마지막에 나옴
- 사용 사례: BFS 구현, 캐시 구현, 대기열과 같이 우선순위가 같은 작업, 선입선출, 프로세스 관리

## 그래프

- 노드와 간선을 모아놓은 자료구조
- 여러개의 고립된 부분 그래프로 구성될 수 있음
- 트리와는 달리 루트 노드, 부모-자식 관계라는 개념이 없음
- 순회는 DFS나 BFS로 이루어짐
- 순환 또는 비순환 그래프로 나뉨
- 방향 그래프와 무방향 그래프로 나뉨

## 트리

- 그래프의 한 종류 - 사이클이 없는 연결 그래프 또는 방향성이 있는 비순환(Acyclic) 그래프의 한 종류임
- 노드가 N개인 트리는 항상 N-1개의 간선을 가짐
- 루트에서 어떤 노드로 가는 경로는 유일함. 임의의 두 노드 간의 경로도 유일함. 즉, 두개의 정점 사이에 반드시 1개의 경로만을 가짐.
- 트리의 종류 : 이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등
- 탐색에는 전위, 후위, 중위 순회 방법이 있음. 루트 노드를 언제 방문하는지를 기준으로 기억하면 됨.

| 전위 순회                      | 중위 순회                      | 후위 순회                      |
| ------------------------------ | ------------------------------ | ------------------------------ |
| 루트 > 왼쪽 자식 > 오른쪽 자식 | 왼쪽 자식 > 루트 > 오른쪽 자식 | 왼쪽 자식 > 오른쪽 자식 > 루트 |

### 힙

- 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
- 여러 값들 중 최댓값/최솟값을 빠르게 찾아내도록 만들어짐
- 최소 힙은 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작은(최대 힙은 큰) 이진 트리를 말한다.

### 이진탐색트리

- 왼쪽 서브트리에는 부모 노드보다 key 값이 작은 노드가, 오른쪽 서브트리에는 부모 노드보다 key 값이 큰 노드가 오는 트리
- 이진탐색트리에서 중위순회를 하면 오름차순으로 정렬된 key값을 얻을 수 있음. 즉, 그래프를 봤을 때 단순히 왼쪽에 있는 노드부터 출력됨.

### Red Black Tree

참고 링크: https://zeddios.tistory.com/237

- 이진 탐색 트리는 최악의 경우 탐색, 삽입, 삭제에 걸리는 시간이 n일 수 있음 (평균은 logn)

- 이진 탐색 트리의 일종이면서 Tree의 밸런스가 무너지지 않게 하여 최악의 경우에도 logn의 시간복잡도를 갖게 하기 위한 대표적인 예시가 Red Black Tree

- 균형잡힌 트리로 높이가 O(logn)임

- 정의 : 아래 정의들로 인해 Red Black Tree의 높이가 logn에 바운드된다.

  - 1. **Root Property** : 루트노드의 색깔은 **검정(Black)**이다
  - 2. **External Property** : 모든 **external node들은 검정(Black)**이다
  - 3. **Internal Property** : 빨강(Red)노드의 자식은 **검정(Black)**이다 == No Double Red(빨간색 노드가 연속으로 나올 수 없다.) 
  - 4. **Depth Property** : 모든 리프노드에서 **Black Depth는 같다** == 리프노드에서 루트노드까지 가는 경로에서 만나는 블랙노드의 개수는 같다. 


---

# 📮 네트워크

## OSI 7계층

1. 물리 계층: 전기 신호 (bit)
2. 데이터 링크 계층: MAC주소 / 이더넷 / (frame)
3. 네트워크 계층:  IP (packet)
4. 전송 계층: TCP, UDP / 포트 번호 / (segment)
5. 세션 계층: 통신을 관리하기 위한 방법 제공
6. 표현 계층: 코드 간의 번역 담당. MIME 인코딩, 암호화, 압축 등
7. 응용 계층

## TCP/UDP

네트워크 계층 중 전송 계층 (4단계) 에서 사용하는 프로토콜.

### TCP (Transmission Control Protocol)

데이터를 메세지의 형태 (세그먼트 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.

TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.

장치들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 **연결형 서비스**. 가상 회선 방식을 제공.

3 way handshaking: TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정. 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립. (a:SYN > b:SYN+ACK > a:ACK)

4 way handshaking: TCP 의 연결을 해제하는 과정. (a:FIN > b:ACK > b:FIN > a:ACK)

흐름제어 (송수신하는 곳의 데이터 처리 속도를 조절해 수신자의 버퍼 오버플로우를 방지. 송신하는 곳에서 너무 데이터 빨리 보내는 것 방지), 혼잡제어 (네트워크 내의 패킷 수가 넘치지 않게 방지)

높은 신뢰성, 느린 속도

전이중(전송이 양방향으로 동시에 일어날 수 있다), 점대점(각 연결이 정확히 2개의 종단점 가짐) 방식. 멀티캐스팅 브로드캐스팅 지원 X.

연속성보다 신뢰성 있는 전송이 중요할 때 사용됨.

### UDP (User Datagram Protocol)

데이터를 데이터그램 단위로 처리하는 프로토콜.

비연결형 서비스. 연결을 위해 할당되는 논리적 경로가 없으며 각각의 패킷은 다른 경로로 전송됨. 각각의 패킷은 독립적인 관계.

정보를 주고 받을때 정보 보낸다! 받는다! 는 신호절차 X

UDP 헤더의 checksum 필드를 통해 최소한의 오류만 검출.

신뢰성 낮고 속도 빠름. 신뢰성보다는 연속성이 중요한 서비스 (ex.streaming) 에 사용됨.

### 참고

TCP/UDP는 각각 별도의 포트 주소 공간을 관리함. 같은 포트 번호 사용해도 무방함. 두 프로토콜에서 동일한 포트번호를 할당해도 서로 다른 포트로 간주.

## 웹

### HTTP, HTTPS

HTTP: 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고받을 수 있는 프로토콜. TCP, UDP를 사용하며 80번 포트를 사용한다. 비연결성, 무상태성 의 특징을 가짐.

HTTPS: HTTPS는 TCP위에 놓인 보안계층(SSL or TLS)위의 HTTP. 기본 TCP/IP 포트로 443 포트를 사용. 



### REST API





---

# 🖥 운영체제

## 프로세스

- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

- 운영체제로부터 시스템 자원을 할당받는 작업의 단위

- 할당받는 시스템 자원의 예로는 CPU시간, 주소 공간, Code/Data/Stack/Heap 구조의 독립된 메모리 영역이 있음

- 프로세스당 최소 1개의 스레드를 가지고 있음

- 각 프로세스들은 별도의 주소 공간에서 실행되기에 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음. 접근하려면 프로세스 간 통신 IPC를 사용해야 함 - IPC는 운영체제의 도움이 필요하다. OS에서 내부적으로 메세지 큐를 두거나, 파이프를 만들거나, 소켓을 이용하는 방법 등이 있다.

### 프로세스의 상태

![Introduction of Process Management - GeeksforGeeks](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2015/06/process-states1.png)

프로세스는 5가지 상태 중 하나로 존재한다. 

new로 생성된 이후 실행 가능한 상태가 되면 ready. ready 상태의 프로세스는 스케줄러에 의해 running 상태가 되어 실행되다가 I/O 혹은 이벤트 대기에 의해 waiting 상태가 되거나, interrupt에 의해 ready 상태가 된다.

waiting 상태였던 프로세스는 I/O 나 이벤트가 완료됨에 따라 다시 ready 상태가 된다.

실행 중이던 프로세스가 종료되면 terminated가 되고, OS에 의해 자원이 회수된다.

### 프로세스 스케줄링

싱글 코어 프로세서의 경우 동시에 여러 프로그램을 실행할 수 없어, 실제로는 시분할을 통해 각 시간 분할마다 다른 프로그램을 실행하는 것으로 동시에 여러 프로그램을 실행하고 있는 것 같은 효과를 준다.

스케줄러는 장기 스케줄러, 단기 스케줄러로 나뉜다. 

스케줄링 방법은 선점형과 비선점형으로 나뉜다. I/O 작업이나 wait 시스템 콜로 waiting 상태가 되는 경우 비선점형 스케줄링 방식이라고 하며, 프로세스가 실행 중에 timeout 등으로 인해 waiting 상태로 변경될 수 있다면 선점형 스케줄링이라고 한다.

#### 스케줄링 큐

job Q: 메인 메모리에 있고, disk에서 가져온다

ready Q: 메인 메모리에 있는 프로세스를 CPU에 올린다

device Q: 키보드 Q, 프린트 Q 등 I/O와 관여

#### 비선점 프로세스 스케줄링

- FCFS 스케줄링: 선입선출 (arrival time) - convoy effect: 긴 프로세스가 큐에 있어서 뒤의 짧은 프로세스가 오래 대기하는 현상
- SJF 스케줄링: 동작시간이 제일 작은 것 우선 처리. 동작시간은 프로세스에 대한 정보나 로그를 통한 예측으로 서비스 : starvation 발생 가능
- HRRN 스케줄링: 수행 시간이 긴 프로세스의 무한 대기 현상을 방지하기 위한 기법으로, 준비 Q에 있는 프로세스들 중 응답률이 가장 높은 프로세스에게 높은 우선순위를 준다. (비선점) 응답률 = (대기시간 + CPU 요구량) / CPU 요구량. 즉, 대기시간이 올라갈 수록 응답률이 높아진다.

#### 선점 프로세스 스케줄링

- RR 스케줄링: FCFS 스케줄링을 기반으로 CPU를 할당하되, 각 프로세스는 한번에 쓸 수 있는 시간 할당량 (time quantum) 이 지나면 시간 종료 인터러브에 의해 CPU를 뺏기는 선점 방식. 시간 종료가 되면 준비 Q의 끝에 들어가고, 준비 Q의 맨 앞에 있는 프로세스가 CPU를 받게 된다. RR 방식은 CPU 독점은 방지하지만 CPU 선점에 따른 context switching의 오버헤드를 감수해야 한다.
- SRTF 스케줄링: 시간마다 프로세스의 burst time(동작시간)을 비교하여 남은 burst T가 짧은 프로세스를 우선 처리하는 알고리즘. 중간에 큐에서 강제로 빼기에 선점 스케줄링임. 같은 burst T를 가지면 FCFS로 동작한다. starvation은 aging으로 해결한다.
- 다단계 큐 스케줄링: 커널 내의 준비 Q를 여러개의 Q로 분리하여 Q 사이에도 우선순위를 부여하는 스케줄링 알고리즘.
- 다단계 피드백 큐 스케쥴링: 다단계 큐 스케줄링에서 발전된 방식으로 프로세스들이 큐를 갈아탈 수 있다.
- RM(rate-monotonic) 스케줄링: 정적 우선순위 스케줄링이다. 수행 주기가 가장 짧은 프로세스(CPU를 더 자주 필요로 하는 태스크)에게 가장 높은 우선순위를 부여하는 정책. 우선순위가 고정되기 때문에 구현이 단순하고 예측성이 좋다.
- EDF(earliest deadline first) 스케줄링: 동적 우선순위 스케줄링이다. 마감 시간에 따라 우선순위를 동적으로 부여한다. 스케줄링 이벤트가 일어날 때마다 큐에서 마감시간이 가장 가까운 프로세스를 탐색하여 다음에 수행되도록 함. 수학적으로 최적이지만, 현실적으로 프로세스의 마감시간을 예측하는 것이 어렵고 문맥교환의 비용때문에 실제로는 RM 스케줄링을 많이 사용함.

## 스레드

프로세스 내에서 실행되는 흐름의 단위.

쓰레드마다 다른 실행흐름을 가지므로 각자 레지스터 집합과 스택 영역을 가지며, 힙 영역은 공유된다.

![Multi Thread Programming](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998BB43D5A6E7E6912)

### 멀티스레딩

사용자가 생성하는 스레드는 유저 수준 스레드, 실제 시스템에서 실행되는 스레드를 커널 수준 스레드라고 한다. 멀티스레딩을 지원하는 방법 다대일, 일대일, 다대다는 유저 수준 스레드와 커널 수준 스레드를 어떤 방식으로 매핑하느냐의 차이이다.



## 동기화

### Thread safe

멀티스레드 환경에서 여러 스레드가 동시에 하나의 공유 자원에 접근할 때 (race condition), 의도한 대로 동작하는 것을 Thread-safe하다고 함. 

Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 하고, 이를 '상호배제'라고 한다.동기화 기법으로는 Mutex나 Semaphore 등이 있음.

임계영역이란 문제의 원인이 될 수 있는 코드 블록으로, 배타적 접근 (한 순간에 하나의 쓰레드만 접근)이 요구되는 리소스에 접근하는 코드블록을 의미함.

### Reentrant

재진입성 이라는 의미로, 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미임. 해당 서브루틴에서는 공유자원을 사용하지 않으면 됨. (전역 변수 사용, 반환 하지 않고 호출 시 제공된 매개변수만으로 동작) Reentrant 하다면 Thread-safe 하지만, 역은 성립하지 않는다.

### 동기화 객체의 종류

#### 스레드 동기화 방법

- 실행 순서의 동기화: 스레드가 반드시 따라야 할 실행 순서를 정의
- 메모리 접근에 대한 동기화: 실행 순서가 중요한 것이 아니라 한 순간에 하나의 스레드만 접근하면 되는 상황을 의미

#### 동기화 기법의 종류

- 유저 모드 동기화: 커널코드가 실행되지 않는 동기화 기법으로, 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화가 있음. 성능상 이점 / 기능상 제한
  - 크리티컬 섹션의 동기화 방식은 메모리 접근 동기화에 사용한다. 열쇠를 얻은 자만이 임계영역에 들어갈 수 있다는 것.
  - 인터락 함수 기반의 동기화는 함수 내부적으로 한 순간에 하나의 쓰레드에 의에서만 실행하도록 동기화되는 것. 크리티컬 섹션 동기화 기법도 내부적으로는 인터락 함수를 기반으로 구현
- 커널 모드 동기화: 커널에서 제공하는 동기화 기능을 활용하는 방법으로, 커널 모드로의 변경이 필요하므로 성능 제한 / 다양한 기능. 뮤텍스, 세마포어, 이벤트 기반의 동기화가 있음.
  - 뮤텍스: 열쇠에 비유할 수 있는 것이 뮤텍스 오브젝트. 호출하는 과정에서 모든 초기화가 이뤄지므로 초기화 함수의 호출이 필요 없음. 
  - 세마포어: 뮤텍스와 비슷하지만 세마포어는 카운트 기능이 존재함. 임계 영역에 접근 가능한 쓰레드 갯수를 조절할 수 있음.

#### 뮤텍스와 세마포어

하드웨어 지원을 통해 어떤 변수의 값 수정을 원자적으로 가능하게 함으로써 뮤텍스 록이나 세마포어 등의 해결방법을 제안한다.

뮤텍스: 공유 자원 데이터에 여러 **스레드**가 접근하는 것을 막는 것. 상호배제라고 하며, 크리티컬 섹션을 가진 스레드의 running time이 겹치지 않게 단독으로 실행하게 하는 기술. 다중 프로세스들의 공유 자원에 대한 접근을 조율하기 위해 synchronized 또는 lock을 사용함. 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없음.

세마포어: 공유된 자원 데이터를 여러 **프로세스**가 접근하는 것을 막는 것. 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화시키는 기술. 리소스 상태를 나타나는 카운터로 생각할 수 있으며, 운영체제(커널)의 저장장치 내의 값임. 일반적으로 긴 시간을 확보하는 리소스에 대해 이용함. 2진수 값을 가지거나, 추가적인 값을 가질 수도 있음.

모니터: 록을 얻는 방법은 잠재적으로 데드록이 일어날 가능성을 가진다. 모니터 방법은 한번에 하나의 프로세스만 모니터에서 활동하도록 보장해준다. 어떤 공유 데이터에 대해 모니터를 지정해놓으면, 프로세스는 그 데이터를 접근하기 위해 모니터에 들어가야만 한다.

[뮤텍스와 세마포어의 차이점]

1. 관리하는 동기화 대상의 개수: 뮤텍스는 동기화 대상이 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용함.

2. 뮤텍스는 Binary 세마포어 (상태가 0,1뿐). 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.

3. 세마포어는 소유할 수 없지만, 뮤텍스는 소유가 가능하다.

4. 뮤텍스는 뮤텍스를 소유하고 있는 스레드만 이 뮤텍스를 해제할 수 있다. 하지만 세마포어는 아무나 세마포어를 해제할 수 있다.

## 동기 비동기

동기란? 다수의 개체들이 동일한 무언가를 가지는 것. 또는 무언가가 동일하게 되는 것. 두개의 프로세스가 데이터를 주고 받을 때 주고받는 순서(또는 시간)가 일정하다는 것을 뜻한다. 비동기는 동기가 아닌 것.

#### 동기적

어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행함. 데이터를 주고 받는 순서가 중요할 때 사용된다. 

#### 비동기적

어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다리지 않고 (작업을 위임하고) 다음 작업을 수행한다. 요청했던 작업이 끝나면 결과를 받고, 그에 따른 추가 작업이 있다면 수행한다. 요청 순서에 상관없이 동시에 다수의 작업을 처리할 수 있다는 장점이 있음.

## 교착 상태

### 교착 상태의 개념과 조건

교착상태 = 데드락

데드락이란? 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생함.

교착상태의 4가지 조건

1. 상호 배제: 공유 자원에 대한 접근 권한이 제한된다. (혹은 자원의 양이 제한되어 있을 때)

2. 점유 대기(들고 기다리기): 공유자원을 가지고 있는 프로세스가, 그 접근권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.

3. 비선점(선취 불가능): 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.

4. 순환대기: 두개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

대부분의 데드락 방지 알고리즘은 4번 조건 (사이클) 을 방지하는데에 초점이 맞춰져있다.

데드락에 대한 해결방법은 크게 예방, 회피, 감지, 복구 방법이 있다.

## context switching

현재 진행하고 있는 Task(프로세스 또는 스레드)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정.

### PCB

참고 자료: https://jhnyang.tistory.com/category/%EB%B3%84%EA%B1%B8%EB%8B%A4%ED%95%98%EB%8A%94%20IT/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20OS

운영체제는 각 프로세스를 관리하기 위해 PCB라는 별도의 자료 구조로 프로세스들을 관리한다. PCB에는 프로세스가 실행되는 동안 필요한 정보인 Program couter이나 레지스터 값들, 가상 메모리를 위한 페이지 테이블, 열었던 파일 목록 등이 포함된다.

### context switching 과정

- Task의 대부분의 정보는 레지스터에 저장되고 PCB(Process Control Block)라는 별도의 자로구조로 관리된다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장한다 (Process Stack, Ready Queue)
- 다음 실행할 Task의 PCB 정보를 읽어 레지스터에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.

쓰레드의 context switching 비용이 Process의 context switching 비용보다 훨씬 저렴하다. 왜? 쓰레드는 stack 영역을 제외한 모든 메모리(code,data,heap)를 공유하기 때문에. stack 영역만 변경하면 되어서 비용이 적게 든다.

## 메모리 관리

모든 프로세스는 메모리에 로드하여 실행함. 수많은 프로그램이 동시에 실행되고, 어떤 프로세스가 함부로 커널 메모리 영역을 건드린다던가 하면 위험하다. 이에 메모리 관리 전략이 필요하다.

자료 출처: https://jhnyang.tistory.com/247

### 주소 변환과 MMU

컴파일 타임, 로드 타임, 런타임 중 주로 런 타임 바인딩 (실행 시간 바인딩) 을 사용한다. 프로세스에서 물리 메모리로 직접 접근하지는 않고, 주소 변환을 통해 접근한다.

Execution time에 진행되는 런타임 주소 바인딩에는 MMU 하드웨어 (CPU 코어 안에 탑재되어 가상 주소를 실제 메모리 주소로 변환해주는 장치) 가 도움을 준다. base와 limit 레지스터를 이용한 방법이다. 어떤 주소에 대해 base보다 높고, base+limit보다는 낮은 주소를 참조해야만 하도록 하는 하드웨어다. 만약 이 범위를 벗어나면 trap을 작동시켜 에러(memory protection fault)를 발생시킨다. 이렇게 base address 값을 더해서 실제 physical address 주소를 만드는 방법을 contiguous allocation이라고 한다. logically contiguous = physically contiguous

기준점의 위치가 다르더라도, offset이 같기때문에 더하기를 통해서 물리적 주소도 논리적 주소처럼 연속적으로 배치되는 것. 이게 바로 연속적 메모리 할당이다. (contiguous allocation)

하지만 이런 contiguous allocation 방법은 Fragmentation이라는 치명적인 단점을 가지고, 이는 paging의 발단이 되었다.

### External fragmentation 외부 단편화

총 공간을 계산해봤을 때 요청을 만족할만한 충분한 메모리가 있음에도, 가능한 곤간들이 연속적이지 않을때 external fragmentation이 발생한다. (외부 단편화) external fragmentation을 위해 fit하게 넣는 3가지의 방법이 있다. 최초적합, 최적적합, 최악적합. 가능한 holes 중 최적의 삽입 공간을 선택하는 것.

외부 단편화를 해결하는 가장 쉬운 방법은 compaction. 하지만 이를 위해선 보조 기억 장치에 임시로 복사하고 옮기는 과정이 필요한데, 이는 I/O 과정에서 병목을 낳아 좋은 방법은 아니다. 이를 해결하기 위해 나온 방법이 paging.

### Paging

#### 페이징

프로세스를 일정 크기의 페이지라고 불리는 블록들로 분할해서 메모리에 적재하는 방식이 바로 페이지.

각각의 페이지는 물리 메모리의 프레임과 맵핑한다.

페이지를 가리키는 논리주소에서 프레임을 가리키는 물리주소로 변환한다.

logical address와 physical address를 동일한 크기(=고정 분할)로 자르고, mapping한다. 하나의 프로세스를 연속적으로 배치할 필요가 없는 것. 이전에 본 연속할당은 프로세스별로 메모리 할당 크기가 달라서 가변 분할이다.

####internal fragmentation

메모리를 고정 크기로 잘라서 할당하다가 남는 자투리. 이게 Internal Fragmentation이고 external fragmentation보다 훨씬 작다.

#### page와 frame

논리주소공간을 동일한 크기로 나눈 것을 page, 물리주소공간을 동일한 크기로 나눈 것을 frame이라고 한다. 똑같은 크기로 나눈거지만 어떤 대상을 나눴냐에 따라 명칭이 달라지는 것.

페이지를 찾는 작업(논리적 주소를 물리적 주소로 변환하는 과정)은 매우 빠르게 수행되어야 하고, 이를 위해 Page table이라는 하드웨어의 지원을 받는다.

논리주소에는 page number과 offset이, 물리 주소에는 frame number과 offset이 존재한다.

#### TLB

CPU가 physical memory에 접근하기 위해선 페이지 테이블에 한번, 실제 메모리에 한번 이렇게 2번 접근해야 한다. 빠른 성능을 위해 Associative memory인 TLB(translation look-aside buffer 변환 색인 버퍼)를 사용한다.

### swapping

물리 메모리에 공간이 부족하다면? 실행중이던 프로세스가 손상되면 안되므로 OS에서는 스왑핑이라는 기법으로 실행중이던 프로그램의 메모리를 보조 기억 장치에 저장시키고 메모리를 비우는 방법을 사용한다.

보조 기억장치는 아주 느리므로 물리 메모리 전체가 아닌, 일부에 의해서 일어난다.

동시에 더 많은 프로세스를 실행한다고 해서 CPU 사용량이 계속 증가하기만 하는 것은 아니다. 스왑핑을 위한 IO 작업이 많이 발생하면 CPU 사용량이 떨어진다. 이때, CPU사용량이 급감하기 시작하는 것을 쓰레싱이라고 한다.

### 페이지 교체

원하는 페이지가 물리 메모리에 존재하지 않으면 (페이지 폴트), 어떤 페이지는 내려놔야 한다. 물리 메모리에서 내려갈 페이지를 선택하는 알고리즘은 여러가지가 있다.

- FIFO - 먼저 참조된 페이지가 victim
- LRU (Least recently used) - 가장 과거에 참조했던 페이지가 victim. counter이나 stack으로 구현 가능



## 커널 메모리 할당

커널 메모리는 유저 모드 프로세스의 메모리 할당과는 다르게, 메모리 풀을 이용해서 메모리를 할당한다. 

- 커널에서 사용하는 자료구조들은 크기가 다양하고 페이지보다 용량이 적다. 따라서 많은 OS에서 커널코드/데이터에는 페이징을 적용하지 않고 있다.
- 유저모드 프로세스에게 할당된 메모리는 물리적으로 연속적이지 않아도 큰 상관이 없지만, 커널 메모리 공간은 하드웨어 장치로부터 직접적으로 물리 메모리에 접근되기에 물리적으로 연속적일 필요가 있다.
- buddy system (물리적으로 연속된 메모리 공간을 2의 지수로 쪼개어 사용), slab allocation (메모리를 커널에서 사용하고 있는 자료구조들의 객체로 취급) 방법 등으로 커널 메모리를 관리한다.



## I/O 시스템

I/O 방식은 폴링 방식과 인터럽트 방식으로 나뉜다.

### polling

주기적으로 장치를 확인하여 데이터를 입출력하는 방법으로, 장치를 위해 busy waiting하게 되어 시간을 많이 낭비한다.

### interrupt

입출력 수행 후 인터럽트를 통해 작업 종료를 알려주게 되므로 주기적으로 다시 확인할 필요가 없다.



---

# 💽 데이터베이스

참고자료: https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md

주요 포인트 - `트랜잭션 관리 및 동시성 제어`, `복구`, `저장장치`, `색인`, `질의 cㅓ리`

## DB 관련 개념

### DB의 계층

DB > 관계(Relation) > 페이지(Page) > 레코드(Record)

페이지 구성 방법으로는 슬롯  페이지 구조가 널리 쓰인다. 페이지의 헤더에는 페이지의 ID, 소유자, 남은 공간 등의 정보와, 슬롯 테이블이 있다. 각 슬롯은 실제 레코드의 주소를 가진다. 외부에서는 페이지 번호와 슬롯 번호만 알면 해당 레코드가 접근할 수 있다.

### DBMS

DBMS란? 데이터베이스를 관리하며 응용 프로그램들이 DB를 공유하며 사용할 수 있는 환경을 제공하는 소프트웨어.

- Oracle, MS_SQL, MY_SQL 등

### RDB (관계형 데이터 모델)

RDB에는 개체-관계 모델링 방법으로 데이터를 구조화한다. 중복된 데이터가 존재하면 DB를 관리하는 과정에서 이상이 생길 수 있다. 함수 종속성을 확인하면 어떤 이상이 존재할지 알 수 있으며, 함수 종속성을 없애기 위해 구조를 변경하는 작업을 정규화라고 한다.

RDB에서는

- 관계 = 테이블
- 행 = 레코드 (행의 개수: Cardinality) = 튜플
- 속성 = 컬럼 (속성의 개수: 차수 Degree) = Attribute

RDB는 관계의 집합과 제약 조건의 집합으로 이루어져있다. 제약 조건에는 키 제약 조건, 개체 무결성 제약 조건, 참조 무결성 제약 조건 등이 있다.

키는 슈퍼키, 후보키, 기본키(primary key)로 나뉜다. 후보 키는 슈퍼키 (모든 행을 유일하게 식별할 수 있도록 하는 속성의 집합) 중 가장 속성의 개수가 적은 것. 후보 키들 중 기본키는 하나. 모든 관계는 단 하나의 기본키만을 가진다. 

참조 무결성 제약 조건 = 외래 키의 대상 관계에 그 키를 가진 행이 반드시 존재해야 한다는 제약. 이 제약으로 인해 관계있는 데이터가 반드시 DB에 존재한다는 보장을 할 수 있다.

### 스키마

스키마란? DB에서 데이터의 구조, 데이터의 표현 방법, 데이터 간의 관계를 형식 언어로 정의한 구조

3단계 스키마 구조: 외부(각 사용자 관점)/개념(모든 사용자 관점)/내부 스키마 (물리적으로 DB접근)

## 무결성 제약 조건

무결성 제약 조건을 이용하면 잘못된 데이터가 DB에 입력되고 유지되는 것을 막을 수 있다. 제약조건은 SQL, 데이터 정의 언어에 의해 추가/삭제/수정된다.

대표적인 무결성 제약 조건으로는 NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK.이 있다.

## 정규화 (Normalization)

참고 링크: https://yaboong.github.io/database/2018/03/09/database-normalization-1/

DB를 잘못 설계하면 데이터 중복으로 인한 공간낭비 + 부작용을 초래한다. 대표적 이상으로는 삽입, 갱신, 삭제 이상이 있다. RDB 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화라고 한다.

정규화를 수행하려면 속성들간의 관련성을 파악해야 하는데, 이 속성들간의 관련성을 함수적 종속성이라고 한다.

### 함수적 종속성

X -> Y (X는 결정자, Y는 종속자. X가 Y를 함수적으로 결정한다. Y가 X에 함수적으로 종속되어 있다.)

X에 의해 Y가 고유하게 구분되면 X -> Y이다.

부분 함수적 종속: 속성집합 Y 가 속성집합 X 의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다.

완전 함수적 종속: 속성집합 Y가 속성집합 X 전체에 대해서만 함수적으로 종속된 경우를 말한다.

이행적 함수 종속: X,Y,Z에 대해 X->Y이고 Y->Z 이면 X->Z가 성립한다. 이때 Z가 X에 이행적으로 함수 종속되었다고 한다.

일반적으로 하나의 관계에는 하나의 함수적 종속성만이 존재하도록 정규화한다. 즉, 함수적 종속성을 이용해서 연관성 있는 속성들을 분류하고, 각 릴레이션들에서 이상현상이 생기지 않도록 하는 과정을 말한다.

### 이상 현상의 종류

- 삽입 이상 : 데이터 삽입 시 의도치않에 원하는 값들도 함께 삽입하게 되는 현상
- 삭제 이상(삭제할때 의도치 않은 값들도 함께 삭제하는 현상)
- 갱신 이상(관계의 행에 있는 속성값을 갱신할 때)

정규화로 위의 이상들이 일어나지 않도록 할 수 있다. 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF까지 있다. 보통 3NF가 되었으면 정규화되었다고 말한다. 정규화 과정에서 주의할 점은, 정규화를 통해 분해된 릴레이션들이 조인을 통해 원래의 구조로 복원될 수 있어야 한다는 것이다.

### 정규형의 단계

1. 제 1 정규형: 테이블의 각 속성이 원자적이어야 함.
2. 제 2 정규형: 1정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**되면 제 2정규형이다.
3. 제 3 정규형: 2정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다. X->Y, Y->Z 2개의 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분해한다.

3NF를 만족하는 릴레이션의 후보키가 1개밖에 없고, 그 후보키가 기본키일 경우 항상 BCNF를 만족한다. 하지만 3정규형을 만족해도 후보키가 여러개일 경우 이상현상이 나타날 수 있다. 이를 해결하기 위한 정규형이 보이스-코드 정규형이다. (=Strong 3NF)

BCNF: X -> Y는 trival FD 이거나 (Y가 X의 부분집합), X는 릴레이션 R의 슈퍼키이다. = 즉 모든 결정자가 KEY인 경우 BCNF이다.

BCNF를 위반하는 릴레이션에 대한 정규화 과정 (분해과정) 은 다음과 같다.

- BCNF를 위반하는 nontrivial FD X -> Y를 찾는다
- 2개의 릴레이션 [XY로 구성된 릴레이션 하나, X와 나머지 속성들로 구성된 릴레이션 하나] 으로 분해한다.
- 두개의 릴레이션에서 기존 릴레이션에서 결정자 역할을 했던 속성을 키로 해준다.

## 트랜잭션

### 트랜잭션이란?

트랜잭션: 데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산(읽기,쓰기)들의 집합으로, DBMS는 트랜잭션들의 집합으로 정의할 수 있다.

하나의 트랜잭션은 commit 되거나 rollback 된다. 

### 트랜잭션의 성질 (ACID):

- 원자성 (Atomicity): 트랜잭션 내의 모든 연산들이 정상적으로 적용되거나, 아무것도 적용되지 않아야 한다.

- 일관성 (Consistency): 트랜잭션 수행 전 DB가 무결한 상태였다면 수행 후에도 DB는 무결한 상태여야 한다.

- 고립성 (Isolation): 여러 트랜잭션이 동시에 실행되고 있어도 사용자는 자신의 트랜잭션만 실행되고 있다고 느껴야 한다.

- 지속성 (Durability): 성공적으로 수행된 트랜잭션은 시스템 장애가 발생하더라도 DB에 반영되어야 한다.

### 트랜잭션의 상태:

![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/transaction-status.png)

### 직렬 가능성 (serializability)

참고 자료: https://m.blog.naver.com/renucs/220542396476

트랜잭션이 수행되는 순서를 스케줄이라고 한다. 트랜잭션이 순차적으로 수행되는게 아니라, 인터리빙하게 수행되는 경우 트랜잭션 내부 연산 순서에 따라 다른 결과가 나타날 수 있다.

직렬성을 가진 스케줄이란, 각각의 트랜잭션이 동시에 수행되더라도 순차적으로 수행된 스케줄과 실행 결과가 동일한 경우를 의미한다. 이를 직렬 가능 스케줄이라고 한다. (Serializable schedule)

직렬 스케줄과 동일함을 정의하는 방식으로 충돌 직렬 가능성과 뷰 직렬 가능성이 있다. 모든 충돌직렬은 뷰 직렬이지만, 그 역은 성립하지 않는다. (충돌직렬이 더 엄격한 스케줄)

#### 충돌 직렬 가능성

동일한 데이터에 대해 두 연산이 이뤄질 때 최소 하나의 연산이 쓰기 연산이면 두 연산은 충돌한다고 한다. 비 충돌 연산은 순서가 바뀌어도 실행결과에 차이가 없지만, 충돌 연산은 순서에 따라 실행 결과가 달라지기에 스케줄 결정 시 고려해야 할 대상이다.

스케줄에서 비 충돌 연산의 순서를 바꾸어 직렬 스케줄이 된다면 충돌 직렬 가능 스케줄이라고 한다.

#### 뷰 직렬 가능성

T1, T2 트랜잭션에 대한 스케줄 S와 S'에 대해

1) 동일한 데이터 Q에 대해 T1이 스케줄S에서 Q의 초기값을 읽는다면 S'에서도 초기값 읽음

2) 동일한 데이터 Q에 대해 T1이 스케줄S에서 W(Q) 후 T2에서 R(Q)를 읽는다면 S'에서도 T1 W(Q)후 T2에서 R(Q)를 읽음

3) 각 항목Q 에 대해 스케줄S에서 T1이 최종 W(Q)를 수행하면 S'에서도 W(Q)수행

즉, 인터리빙하게 수행되는 스케줄 S와 순차적으로 수행되는 스케줄 S'를 비교해서 동일한 테이터 Q를 초기 읽기, 쓰기/읽기, 마지막 쓰기 순서만 같다면 뷰직렬이다.

충돌직렬과 비교했을 때, 읽기/쓰기 순서는 고려하지 않은 것이다. 따라서 blind write 현상(W에 앞서 R를 하지 않기에 Q의 현재 값을 모르는 상태에서 쓰기를 수행하는 것)이 발생할 수 있다. 

#### 직렬 가능한 스케줄 선택

뷰 직렬 가능 스케줄인지 검증하는 문제는 NP-완전 수준의 문제. 현실적으로는 충돌 직렬 가능성에 대해서만 고려하여 직렬 가능 스케줄을 찾는다.

충돌 직렬 가능성을 판별하기 위해서는 스케줄의 연산에 따른 선행 그래프를 사용하면 된다. 노드는 트랜잭션, 충돌하는 데이터가 존재하는 노드 간에 엣지를 두면 선행그래프가 만들어진다. 이 선행 그래프에서 사이클이 존재하면, 충돌 직렬 가능하지 않은 스케줄이다.

#### 다양한 스케줄의 종류

직렬 가능성은 모든 트랜잭션이 실행이 정상적으로 되었을 때만 고려한 스케줄이다. 하지만 DB에서는 항상 장애에 대한 고려가 필요하다.

![img](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190813142109/Types-of-schedules-in-DBMS-1.jpg)

사진 출처: https://www.geeksforgeeks.org/types-of-schedules-in-dbms/

직렬 가능 스케줄이 아닌 스케줄들은 또 아래와 같이 나눌 수 있다.

- 회복 가능 스케줄 (Recoverable schedule): 동일한 데이터 Q에 쓰기 연산을 하는 Ti와, Q를 읽는 Tj 가 있을 경우, Ti가 먼저 완료된 후에 Tj가 완료되는 스케줄. 쓰기 연산을 하는 트랜잭션(Ti)가 도중에 철회되더라도 복구 가능하도록 실행하는 스케줄.
  - 동일한 데이터에 접근했던 트랜잭션이 철회됨에 따라, 다른 트랜잭션도 철회되는 현상을 연쇄 철회 (Cascading rollbacks) 라고 한다. 가능한 연쇄 철회가 일어나지 않도록 해야 한다.
  - Cascadless schedules는 완료된 데이터만을 (committed) 읽도록 허용한다. 즉, 어떤 데이터에 대해 타 트랜잭션이 쓰기 연산을 했다면 그 트랜잭션이 먼저 완료되기를 요구한다.
  - Strict schedule은 어떤 데이터에 대해 쓰기 연산을 한 트랜잭션이 완료되거나 철회되기 전에는, 다른 스케줄이 어떠한 연산 (읽기/쓰기)도 할 수 없게 하는 스케줄이다. 

![img](https://upload.wikimedia.org/wikipedia/commons/f/f1/Schedule-serializability.png)

각 스케줄의 범주는 위와 같다.

### 동시성 제어

운영체제의 멀티프로그래밍처럼, 컴퓨터 자원을 효율적으로 사용하기 위해 여러 트랜잭션들을 동시 실행하고 싶다. 트랜잭션의 성질인 ACID를 지키며 여러 트랜잭션을 동시에 잘 실행하기 위한 것을 동시성 제어라고 한다

우리가 원하는 스케줄은 직렬 가능 스케줄이면서, 회복 가능 또는 연쇄 철회를 방지하는 스케줄이다. 하지만 트랜잭션 전체의 연산을 미리 알 순 없으므로 (다 실행하고 나서야 어떤 스케줄인지 판별 가능), 어떠한 규약을 통해 실행하면 원하는 스케줄대로 실행되게 하는 규약을 찾고 싶다. 이러한 제약을 동시성 제어 규약이라고 한다.

트랜잭션을 올바르지 않게 실행할 경우 다음과 같은 3가지 문제들이 발생할 수 있다.

1) Dirty Read: 수정중인 값(아직 완료되지 않은 값)을 다른 트랜잭션에서 읽는 문제

2) Non-Repeatable Read: 한 트랜잭션에서 같은 쿼리를 두번 이상 수행할 때 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상

3) Phantom Read (Lost Update): 어떤 트랜잭션에서 수정한 값을 다른 트랜잭션에서 수정해버리면서 이전의 갱신을 잃게 되는 문제 - 이를 피하기 위해 색인에 대해 크래빙 방식(트리 기반 규약으로 락을 사용하는 것)으로 락을 거는 방식이 널리 쓰인다. 크래빙 방식은 데드락 처리가 필요하다.

동시성 제어는 위 문제들을 방지하는 방법이다. 동시성 제어 규약으로는 Locking, Timestamp ordering, Multiversion, Optimistic protocol 등이 있으며 상용 시스템에서는 Locking이 주로 쓰인다.

#### Lock based Protocol (Locking)

Lock 모드에는 shared lock과 exclusive lock 2가지가 있다.  S 모드는 읽기 연산을 할 때, X 모드는 쓰기 연산을 할 때 사용된다.

Locking에서 트랜잭션은 모든 읽기/쓰기 연산을 하기 전에 락을 먼저 획득해야 한다. 즉, 한 트랜잭션이 연산을 하는 동안 타 트랜잭션이 관여하지 못하게 막는것을 의미한다. 마치 운영체제의 세마포어와 유사하다.

다른 모드들과 호환 가능한 shared lock과는 달리, exclusive lock 은 다른 모드들과 호환되지 않으므로 단 하나의 트랜잭션만이 exclusive lock 을 가질 수 있다.

응답성과 성능 사이에서 효율적인 Locking 방법을 찾아야 한다.

#### Two phase Locking Protocol - 두 단계 락킹 규약

기본적인 락 규칙 외에도 직렬 가능 스케줄을 만들기 위한 추가적인 규칙이 필요하다. 두 단계 락킹 규약은 직렬 가능 스케줄을 만들기 위한 규약 중 하나로, 확장 단계와 수축 단계로 단계를 나누어 확장 단계에서만 락을 추가로 할당받을 수 있고, 락을 풀기 시작하는 수축 단계가 되면 추가적인 락을 얻을 수 없다.

또, 확장 단계에서는 S,X 모드 락을 얻거나 S > X로 upgrade 하는 것만을 허용하며 수축 단계에서는 S,X 모드 락을 풀거나 X > S로 downgrade 하는 것만을 허용한다.

두 단계 락킹 규약의 변형으로 엄격 (strict) 두 단계 락킹 규약과 엄중 (rigorous) 두 단계 락킹 규약이 있다.

- 엄격 두 단계 락킹 규약: 트랜잭션이 종료될 때까지 쓰기 락을 계속 가져가고, 읽기 락은 중간에 해제 가능하도록 하는 규약. 이를 지키면 연쇄 철회가 일어나지 않는다. 트랜잭션이 끝난 후에야 쓰기 락이 해제되어 타 트랜잭션이 접근할 수 있게 되기 때문이다.
- 엄중 두 단계 락킹 규약: 읽기 락도 트랜잭션 종료 시까지 유지함으로써 트랜잭션 완료 순서대로 직렬된다.

두 단계 락킹 규약을 준수하면 항상 충돌 직렬 가능한 스케줄을 생성한다. 

#### 락 관리

시스템이 연산에 대해 자동으로 락을 획득/해제하도록 하기에 사용자는 이에 대해 신경쓰지 않아도 된다. 락을 관리하는 락 매니저는 락 테이블을 관리하며, 락 관리는 빠른 시간 안에 수행되어야 하므로 메모리에서 관리한다.

락을 사용하며 데드락 발생 위험과, 기아 상태 (starvation) 발생 가능성이 존재한다. 락 충돌이 일어나는 경우 트랜잭션은 락을 획득하기 위해 대기 상태로 기다리기 때문이다.

####  데드락 처리

데드락을 처리하는 방법은 3가지 방식이 있다.

1) 타임아웃: 일정 시간 이상 락을 위해 대기하지 않게 하기.

2) 방지: 두 단계 락킹 규약이 아닌, 그래프 기반 락킹 규약을 사용하기. 또는, wait-die 방식(락 충돌 발생 시 늙은 트랜잭션일 경우 기다리고 어린 트랜잭션일 경우 스스로를 철회하기)이나 wound-wait(늙은 트랜잭션이 젊은 트랜잭션이 가지고 있던 락을 필요로 할 경우 젊은 트랜잭션을 철회시켜버린 뒤 락을 가져가고, 젋은 트랜잭션이 늙은 트랜잭션의 락을 필요로 할 경우 기다리기) 방식 사용하기. 두 방식 모두 오래된 트랜잭션이 유리하다. (오래된 트랜잭션은 이미 많은 작업을 수행했기에 철회 비용이 더 클 가능성이 높기 때문에 우선순위를 높게 주는 것)

3) 감지: 방향성을 가지는 대기 그래프를 이용하기.

### 트랜잭션 고립성 제어

어떤 프로그램은 트랜잭션의 완벽한 일치성을 요구하지 않을 수도 있다. 일치성 수준을 완화하기 위해 보편적으로 사용하는 형식이 두 단계 일치성이다.

트랜잭션을 선언할 때 성능을 위해 고립성 수준을 선택할 수도 있다.

트랜잭션 격리(고립) 수준 (isolation level): 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준.

1) 레벨 0: Read uncommitted - SELECT 가 수행되는 동안 해당 데이터에 shared lock이 걸리지 않는 레벨. 타 사용자가 uncommitted (=dirty) 트랜잭션 데이터인 B를 읽을 수 있다. DB의 일관성을 유지할 수 없다. 데이터 정합성에 문제가 많지만, 집계 연산 같은 작업에서는 유용할 수 있다.

2) 레벨 1: Read committed -  SELECT 가 수행되는 동안 해당 데이터에 shared lock이 걸리는 레벨. Commit이 이루어진 트랜잭션만 조회할 수 있다. (Dirty read 불가능) SQL server이 default로 사용하는 격리 레벨. 가장 많이 선택되는 격리 수준.

3) 레벨 2: Repeatable Read - 데이터 조회시 항상 동일한 데이터 응답을 보장하는 고립수준. 트랜잭션이 완료될 때까지 SELECT 문이 사용하는 모든 데이터에 shared lock이 걸리는 레벨. 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준. MySQL DBMS에서 기본으로 사용하며 이 격리수준에서는 NON-REPEATABLE READ 부정합이 발생하지 않음. (하나의 트랜잭션에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환)

4) 레벨 3: Serializable: 모든 작업을 하나의 트랜잭션에서 처리하는 것과 같은 높은 고립수준. 읽기 작업도 shared lock을 획득한다. 고립수준이 높은 만큼 동시성 처리효율은 떨어지지만, Phantom read를 방지할 수 있다. 하지만 거의 사용되지 않음.

## 장애와 복구

### 장애의 종류

1) 트랜잭션 장애: 데드락이나 사용자의 요구, 시스템의 판단 등에 의해 트랜잭션을 철회시키면서 발생할 수 있는 장애.

2) 시스템 장애: 정전으로 시스템이 변경 사항을 저장장치에 쓰기 전 컴퓨터가 꺼져버리거나, 운영체제문제로 DB가 종료되는 장애 등이 포함됨.

3) 디스크 장애: 하드웨어 결함 등으로 인해 디드크 내용이 소실되는 장애.

장애가 발생하면 시스템이 복구 작업을 해야 한다.

복구 알고리즘은 1) 정상 상태에 복구를 위해 사전에 수행하는 작업(ex.안정 저장 장치에 로그 쓰기)과 2) 장애 발생 후 복구를 위해 수행하는 작업으로 나뉜다.

### 데이터의 위치

DB에서는 한 데이터가

1) 디스크 블록: 기본 존재 위치, 시스템이 종료되거나 메모리가 고장나도 손상 X

2) 메인 메모리 상의 데이터 버퍼 블록: DBMS에 의해 필요한 경우에만 로드됨

3) 트랜잭션 프로세스의 메모리: 시스템 버퍼에 있는 값을 트랜잭션 메모리 공간에 복사해 사용

이렇게 세 곳에 위치할 수 있다. 

### 로그

상용 DB 시스템은 복구를 위해 로그 방식을 사용함. 로그의 핵심은 DB에 변화가 생기기 전, 변화에 대한 기록을 안전 저장 장치에 저장하는 원칙을 지키는 것. (= Write Ahead Logging, WAL)

### 데이터 페이지 버퍼링

데이터 블록이 디스크에 쓰이는 동안은 해당 데이터 블록 내의 데이터가 수정되지 않도록 해야한다. 이를 위해 래치(Latch) 또는 세마포어를 사용한다. 디스크 쓰기 속도는 매우 느리므로 효율을 위해 데이터 페이지도 버퍼링한다.

현대 운영 체제가 대부분 가상 메모리 기법을 사용하므로, 이 때문에 듀얼 페이징 문제(메모리의 내용이 스왑핑에 의해 이미 디스크에 쓰인 상태에서, 그 데이터를 디스크에 쓰려고 할 경우 데이터 페이지가 메모리에 다시 로드된 뒤 디스크에 다시 쓰이는 문제)가 발생할 수 있다. 이를 방지하기 위해서는 운영체제가 DB 시스템의 데이터 블록과 관련된 메모리를 스왑하려는 경우, DB 영역에 쓰기 하도록 협의가 필요하다.

데이터 페이지 버퍼링에는 2가지 정책이 있다.

- Steal 정책: 트랜잭션이 완료되기 전에 디스크 블록에 변경 사항이 쓰일 수 있을지에 대한 정책
- Force 정책: 트랜잭션이 완료되었을 때 항상 디스크 블록에 변경사항을 적용해야 하는지에 대한 정책

### 원격 백업

원격 백업 시스템은 주 시스템이 있는 곳 외에도 다른 지역에 백업 시스템을 두어, 시스템 가용성을 높인다.

주 시스템에 문제가 생겨 백업 시스템이 주 시스템 역할을 수행해야 할 경우, 백업 시스템을 로그들을 이용하여 복구 연산을 해 주 시스템과 같은 상태로 만들면 된다.

이를 위해서는 백업 시스템이 주 시스템으로부터 받은 로그를 즉시 적용해둬야 하며, 이를 hot spare이라고 부른다.

백업 시스템에 로그를 적용시키는 방법엔 One-safe, Two-very-safe, Two-safe 방식이 있다. One-safe 기법은 트랜잭션이 완료되었을 때 주 시스템에만 적용이 완료되면 되는 방식(가장 빠름), Two-very-safe 방식은 트랜잭션이 완료되었을 때 모든 백업 시스템들에 적용이 완료되면 되는 방식(가장 느림), Two-safe 방식은 하나의 백업 시스템에만 적용되면 되는 방식이다.

원격 백업 시스템의 대안으로는 분산 데이터베이스 방식이 있다.

### 저장 장치

DB 시스템의 저장장치로는 **RAID 시스템**이 많이 쓰인다. 

## 색인 (index)

### 색인 개념과 색인의 종류

색인의 목적은 데이터를 빨리 찾는 것에 있다. 색인 유무에 따라 검색 속도의 차이가 매우 크다.

색인의 종류에는

- 정렬 색인: 키를 기준으로 정렬되어 있음: Range 질의에 적합
- 해쉬 색인: 정렬되어 있지 않음: Exact 질의에 적합

이 있다.

어떤 색인을 사용할지는 어떤 질의(Query)를 사용할 지에 따라 다르다. 특정 값의 레코드를 찾는 Exact match 질의와 일정 범위에 속하는 레코드를 찾는 Range 질의로 나뉜다.

- 주 색인: 실제 파일 내 레코드 순서와 동일한 순서로 존재
- 이차 색인: 실제 파일 내 레코드 순서와 무관하게 키에 대해 정렬된 상태로 존재
- 밀집 색인: 모든 레코드에 대한 색인 레코드가 존재
- 희소 색인: 일부 레코드에 대해서만 색인 레코드가 존재

이차 색인은 반드시 밀집 색인이어야 한다. 

### B+ 트리

자료 출처: https://minzoovv.dev/TIL/6.24-i-learned/

B+ 트리는 균형 트리 상태를 유지하는 자료 구조이며, 많은 상용 시스템에서 색인을 위한 자료 구조로 쓰인다. B+ 트리 개념의 기반이 되는 2-3 Tree에 대해 먼저 알아보자.

일반 Binary search tree는 데이터가 정렬된 순으로 삽입될 때 한쪽으로 치우친 unbalanced BST가 되어 모든 기능이 O(n)의 복잡도를 띄게 된다. 이러한 문제가 개선된 트리를 Balanced Search Tree라고 하며, 그 중 대표적인 것이 2-3 Tree가 있다.

#### 2-node, 3-node, ...n-node

2-node는 키가 1개, child node가 2개인 구성을 말한다. n-node는 키가 n-1개, child node가 n개인 노드 구성을 말한다.

#### 2-3 트리

2-node와 3-node의 형태인 node로 이루어진 트리를 2-3 tree라고 한다. 2-3 tree는 균형 트리라는 속성을 가진다.

신규 노드 삽입 시 노드의 키를 비교하며, 2-node의 경우 BTS처럼 작을 경우 왼쪽 서브트리, 클 경우 오른쪽 서브트리에서 삽입이 진행되며 3-node의 경우 키 2개와 비교하여 2개보다 작을경우 왼쪽, 2개보다 클 경우 오른쪽, 둘 다 아닐경우 (가운데 값일 경우) 가운데 서브트리에서 삽입이 진행된다.

2-3 Tree는 Root 노드에서 모든 최하위 자식 노드까지의 거리가 언제가 같기에 언제나 complete balanced tree가 구성된다. 

1) 삽입

2-3 트리의 삽입은 맞는 위치를 탐색하고, 해당 노드가 삽입될 노드를 찾는다. 이렇게 삽입될 노드를 찾으면 그 삽입될 노드가 어떤 상태인지에 따라 동작이 달라진다.

- 삽입될 노드가 2-node인 경우, 해당 노드에 삽입할 값을 추가해 3-Node로 변경해준다.
- 삽입될 노드가 3-node, 부모 노드가 2-node인 경우, 해당 노드에 삽입할 값을 추가해 임시적으로 4-Node로 변경한 후, 가운데 값을 부모 노드로 이동시켜 해당 노드를 3-node로 만들고 부모 노드도 3-node가 되게 한다.
- 삽입될 노드와 부모 노드 모두 3-node인 경우, 2번과 유사하나 2-node인 부모 노드가 나올 때까지 2번을 반복한다. 만약 root node도 3-node라면, root node의 가운데 key값으로 root 노드를 생성하고 기존 root 노드에 남은 2개의 키값으로 자식 노드를 생성하면 된다.

삽입 과정에서 볼 수 있듯, 2-3 트리는 신규 키값이 삽입 될 때 트리의 최하단에 노드가 추가되는 것이 아닐, Root 노트에 키값이 추가되거나 기존 root 노드가 분리되며 Complete Balance 를 유지한다.

2) 삭제

2가지 요소를 신경써야 한다. 1. 해당 노드를 삭제했을 때 균형트리가 유지되는지 2. 노드를 삭제할 때 key가 사라지는 empty node가 없는지. 이를 만족하기 위해 삭제할 키를 검색하는 트리 순회 과정에서 검색되는 노드들을 모두 3-node 또는 4-node로 변환한 후 키를 삭제하게 된다.

이 과정에서 3가지 경우로 나뉠 수 있다.

- root 노드가 2-node이며 root 노드의 자식 노드들도 모두 2-node일 때: 세 node를 합쳐 root 노드를 4-node로 변환한다.

- 현재 노드가 2-node이며 바로 옆 형제 노드가 3-node인 경우, 형제노드의 키값 한개를 부모 노드로, 부모 노드의 키값 한개를 현재 노드로 이동하고, 형제노드의 자식노드 한개를 현재 노드의 자식노드로 만들어 현재 노드를 3-node로 변환한다.

- 현재 노드와 형제 노드가 모두 2-node인 경우, 부모노드의 키값 한개와 현재 노드, 형제 노드의 키값을 모두 합쳐 새로운 4-Node를 생성한다.

위의 변환과정을 거치며 목표 Node에 도달하여 키를 삭제하게 되면 BST처럼 삭제된 키의 우측 서브트리의 최소 키값을 현재 노드에 삽입하고, 우측 서브트리의 최소 키값을 삭제한후 Root노드로 거슬러 올라가며 4-Node를 삽입 과정에서 한것처럼 분리해주면 된다. 🤯

#### B Tree

2-3트리도 B-Tree의 일종이다. n-node 형태의 노드들을 가지는 트리를 B Tree라고 하고, 2-3 Tree는 2차 B Tree라고 한다. 차수에 들어가는 것은 하나의 노드가 최대로 가질 수 있는 데이터의 수를 말한다.

#### B+ Tree

B Tree 트리에서 순회를 하려면 모든 Tree의 노드를 방문해야 한다. 이런 순회 작업 복잡성 문제를 해결하기 위해 제시된 것이 B+ Tree이다.

B+ Tree는 모든 데이터가 leaf 노드에 존재한다. 그리고 탐색을 위한 key값이 되는 노드들은 중복으로 Non-leaf 노드를 구성하게 된다. 즉, 값을 찾기 위한 인덱스 노드와 실제로 그 값을 가지고 있는 리프 노드가 분리되어서 존재하는 것이다.

각 leaf 노드들은 전부 linked list로 연결되어 있어 순차 처리가 가능하다.

[장점]

데이터에 대한 순차 순회에서는 매우 큰 장점을 가진다.

[단점]

Search를 하는 경우, B+ Tree는 무조건 leaf node까지 가야 한다는 단점이 있다.

### 확장 해싱

정적 해싱에서는 균일하고 임의적인 해시 함수를 찾기 어려워 데이터가 많아짐에 따라 충돌로 인한 성능 저하가 발생한다. 확장 해싱은 해시 함수가 동적으로 변하게 함으로써 이 문제를 해결한다.

해시 방법은 exact 질의에만 적합하다. (해시 결과가 기존 데이터의 레코드 순서와 전혀 다른 순서가 되기 때문에) 

### 비트맵

비트맵 색인은 탐색 키의 종류가 적을 때 다중 속성에 대한 질의에 유용한 색인이다. 글의 공개/비공개, 또는 급여를 10000달러 기준으로 범주로 나눠놓은 경우들이 해당된다.

비트맵 색인은 다중 속성에 대한 조건을 비트연산하여 조

## 쿼리 문법의 종류

- DDL(데이터 정의어): CREATE, ALTER, DROP, TRUNCATE 등 데이터베이스 스키마를 정의, 조작하는 언어

- DML(데이터 조작어): SELECT, INSERT, UPDATE, DELETE 등 데이터를 조작하기 위한 언어

- DCL(데이터 제어어): 데이터에 대한 엑세스를 제어하기 위한 언어

### join

조인은 한 DB내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것. 조인은 테이블로 저장되거나 그 자체로 이용할 수 있는 결과 셋을 만들어냄.

조인의 종류

- 내부 조인 (inner join): 2개 테이블의 컬럼 값을 결합함으로써 새로운 결과 테이블을 생성
  - 동등 조인 (EQUI JOIN): 조인 구문에서 동등비교만을 사용
  - 자연 조인 (NATURAL JOIN): 동등 조인의 한 유형으로, 동일한 이름을 가진 컬럼의 각 쌍에 대한 하나의 컬럼만 포함
  - 교차 조인 (CROSS JOIN): 조인되는 두 테이블에서 곱집합을 반환. m행 테이블, n행 테이블이 교차조인되면 m*n개의 행 생성
- 외부 조인 (outer join): 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요할 때.
  - 왼쪽 외부 조인
  - 오른쪽 외부 조인
  - 완전 외부 조인

## ORM

자료 출처: https://digest1.tistory.com/6, https://geonlee.tistory.com/207, https://gmlwjd9405.github.io/2019/02/01/orm.html

Object-Relational-Mapping 객체-관계 매핑: 객체와 RDB의 데이터를 자동으로 매핑해주는 것을 말한다. RDB를 이용하면서도 객체에 대한 표현에 제약을 받지 않고 객체처럼 사용하고자 DBMS 앞 단에서 기능하는 개념.

클래스와 테이블은 원래 호환되지 않지만, 이 불일치를 ORM을 통해 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하여 불일치를 해결한다. 따라서 ORM을 활용하면 SQL을 짤 필요 없이 객체를 통해 간접적으로 DB를 조작할 수 있다.

#### 장단점

장점:

- 객체지향성: SQL이 아닌 클래스의 메서드를 통해 DB를 조작할 수 있기에 개발자가 객체지향적인 코드만 작성하면 된다.

- 유지보수 용이: ORM은 DB에 종속되어있지 않고, 객체로 작성되었기에 재사용이 가능하다.

단점:

- ORM이 모든걸 해결해 줄 수 없다. 속도를 위해 SQL 문을 별도로 튜닝해야 할 수 있다.


---



# 🔑 보안

보안은 시스템을 내외부의 공격으로부터 막는 것이다.

## 암호화

데이터의 보안을 위해서는 암호화가 중요하다.

참고 자료: https://jongmin92.github.io/2020/01/02/Java/rsa/

### 해시

해시 함수는 가변 길이의 데이터를 이용해 고정 길이의 해시 값을 생성하고, 같은 입력 값에 대해서는 같은 출력 값을 보장한다.

해시 값을 가지고는 원본 데이터를 복원해 내는 것이 불가능하다. 유저의 비밀번호는 암호화가 아닌 해시 함수를 통해 생성된 해시 값을 저장해야 한다.

1. 단순 텍스트
2. 단방향 해시 함수의 다이제스트 (digest): 단방향성. 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 다이제스트를 생성. 흔히 사용하는 해시 알고리즘으로는 "SHA-256"이 있다.
3. 솔팅: 솔트란, 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열. 솔팅은 원본 메시지에 솔트를 추가하여 다이제스트를 생성하는 것이다. 사용자별로 다른 솔트를 사용하면 안식 가능성 문제가 크게 개선됨.
4. 키 스트레칭: 여러 단계의 해시 함수를 적용하여 다이제스트를 생성하는 과정.

#### MD5 (message-digest algorithm 5)

128비트의 해시값을 생성하는 해시 함수이다. 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. 하지만 암호화 결함이 발견되어 이제는 MD5 알고리즘을 보안 관련 용도로 쓰는 것을 권장하지 않는다.

#### SHA-256

SHA 알고리즘의 한 종류로서 256비트의 해시 값을 생성하는 해시 함수이다. 표준으로 많이 사용된다.

### 암호화 (Encryption)

암호화는 평문을 암호문으로 변환하는 과정을, 복호화는 암호문을 평문으로 변환하는 과정을 말한다.

#### 대칭키 (비밀키)

- 암/복호화 키가 동일
- 대표 암호알고리즘 : DES, 3DES, TDES, AES, SEED, ARIA 등
- bit 수가 작고 수행시간이 짧다
- 사용이 제한적이다
- 디스크 암호화 등에 사용된다.

#### 비대칭키 (공개키, 개인키)

이제는 비대칭 키 암호화 방식이 대세가 되었다.

- 암/복호화키가 상이하다
- 대표 암호알고리즘 : RSA, ECC 등
- bit 수가 많고 수행시간이 길다
- 비밀범호 암호화등에 사용됨
- 공개키로 암호화한것을 개인키로 복호화한다.

A와 B가 존재하고 A와 B 둘다 공개키와 비밀키를 소유하고 있다. A가 평문을 B에게 보내고자 할 때 A는 B의 공개키를 가져와 암호화하여 전달한다. B는 전달받은 암호문(B의 공개키로 암호화된 평문)을 B의 비밀키로 복호화 하여 평문을 얻는다. 반대로 B 또한 A에게 평문을 전달할 때 A의 공개키를 사용하면 된다.

#### RSA

대표적인 비대칭키 알고리즘이다. RSA는 수학적인 기법을 통해 한 쌍의 키를 생성하고, 한 쌍의 키를 각각 공개키/비밀키라고 부른다.

공개키: 누구에게나 공개될 수 있으며 데이터를 보내는 발신자는 공개키를 통해 정보를 암호화한다.

비밀키: 외부에 노출되지 않도록 안전하게 보관해야 한다. 수신자는 비밀키를 통해 공개키로 암호화된 메세지를 복호화한다.

이렇게 한 쌍의 암호화 키를 이용하는 방식이 RSA 알고리즘이다. SSL/TLS가 통신을 암호화하기 위해 사용하는 대칭키를 교환하기 위해 RSA를 사용하고 있다. RSA와 같은 비대칭키 암호화 방식은 복잡한 수학적 원리로 이루어져있어 많은 CPU 리소스를 소모하기 때문에, 대칭키를 공유할 때만 RSA 방식으로 대칭키를 공유하고, 그 이후로는 공유된 대칭키를 이용해 CPU 리소스를 덜 소모하는 암호화 방식으로 통신한다.