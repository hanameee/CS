참고 Repository: https://github.com/WeareSoft/tech-interview

# 자료구조

자료구조 참고 링크: https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html

## 스택

- LIFO(후입선출): 가장 최근에 추가한 항목이 가장 먼저 나옴
- 사용 사례: 재귀 구현, 브라우저 뒤로가기, 실행취소, 수식 괄호 검사, 후위 표기법 계산

## 큐

- FIFO(선입선출): 가장 최근에 추가한 항목이 가장 마지막에 나옴
- 사용 사례: BFS 구현, 캐시 구현, 대기열과 같이 우선순위가 같은 작업, 선입선출, 프로세스 관리

## 그래프

- 노드와 간선을 모아놓은 자료구조
- 여러개의 고립된 부분 그래프로 구성될 수 있음
- 트리와는 달리 루트 노드, 부모-자식 관계라는 개념이 없음
- 순회는 DFS나 BFS로 이루어짐
- 순환 또는 비순환 그래프로 나뉨
- 방향 그래프와 무방향 그래프로 나뉨

## 트리

- 그래프의 한 종류 - 사이클이 없는 연결 그래프 또는 방향성이 있는 비순환(Acyclic) 그래프의 한 종류임
- 노드가 N개인 트리는 항상 N-1개의 간선을 가짐
- 루트에서 어떤 노드로 가는 경로는 유일함. 임의의 두 노드 간의 경로도 유일함. 즉, 두개의 정점 사이에 반드시 1개의 경로만을 가짐.
- 트리의 종류 : 이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등
- 탐색에는 전위, 후위, 중위 순회 방법이 있음. 루트 노드를 언제 방문하는지를 기준으로 기억하면 됨.

| 전위 순회                      | 중위 순회                      | 후위 순회                      |
| ------------------------------ | ------------------------------ | ------------------------------ |
| 루트 > 왼쪽 자식 > 오른쪽 자식 | 왼쪽 자식 > 루트 > 오른쪽 자식 | 왼쪽 자식 > 오른쪽 자식 > 루트 |

### 힙

- 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
- 여러 값들 중 최댓값/최솟값을 빠르게 찾아내도록 만들어짐
- 최소 힙은 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작은(최대 힙은 큰) 이진 트리를 말한다.

### 이진탐색트리

- 왼쪽 서브트리에는 부모 노드보다 key 값이 작은 노드가, 오른쪽 서브트리에는 부모 노드보다 key 값이 큰 노드가 오는 트리
- 이진탐색트리에서 중위순회를 하면 오름차순으로 정렬된 key값을 얻을 수 있음. 즉, 그래프를 봤을 때 단순히 왼쪽에 있는 노드부터 출력됨.

### Red Black Tree

참고 링크: https://zeddios.tistory.com/237

- 이진 탐색 트리는 최악의 경우 탐색, 삽입, 삭제에 걸리는 시간이 n일 수 있음 (평균은 logn)

- 이진 탐색 트리의 일종이면서 Tree의 밸런스가 무너지지 않게 하여 최악의 경우에도 logn의 시간복잡도를 갖게 하기 위한 대표적인 예시가 Red Black Tree

- 균형잡힌 트리로 높이가 O(logn)임

- 정의 : 아래 정의들로 인해 Red Black Tree의 높이가 logn에 바운드된다.

  - 1. **Root Property** : 루트노드의 색깔은 **검정(Black)**이다
  - 2. **External Property** : 모든 **external node들은 검정(Black)**이다
  - 3. **Internal Property** : 빨강(Red)노드의 자식은 **검정(Black)**이다 == No Double Red(빨간색 노드가 연속으로 나올 수 없다.) 
  - 4. **Depth Property** : 모든 리프노드에서 **Black Depth는 같다** == 리프노드에서 루트노드까지 가는 경로에서 만나는 블랙노드의 개수는 같다. 


---

# 네트워크

## OSI 7계층

1. 물리 계층: 전기 신호 (bit)
2. 데이터 링크 계층: MAC주소 / 이더넷 / (frame)
3. 네트워크 계층:  IP (packet)
4. 전송 계층: TCP, UDP / 포트 번호 / (segment)
5. 세션 계층: 통신을 관리하기 위한 방법 제공
6. 표현 계층: 코드 간의 번역 담당. MIME 인코딩, 암호화, 압축 등
7. 응용 계층

## TCP/UDP

네트워크 계층 중 전송 계층 (4단계) 에서 사용하는 프로토콜.

### TCP (Transmission Control Protocol)

데이터를 메세지의 형태 (세그먼트 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.

TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.

장치들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 **연결형 서비스**. 가상 회선 방식을 제공.

3 way handshaking: TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정. 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립. (a:SYN > b:SYN+ACK > a:ACK)

4 way handshaking: TCP 의 연결을 해제하는 과정. (a:FIN > b:ACK > b:FIN > a:ACK)

흐름제어 (송수신하는 곳의 데이터 처리 속도를 조절해 수신자의 버퍼 오버플로우를 방지. 송신하는 곳에서 너무 데이터 빨리 보내는 것 방지), 혼잡제어 (네트워크 내의 패킷 수가 넘치지 않게 방지)

높은 신뢰성, 느린 속도

전이중(전송이 양방향으로 동시에 일어날 수 있다), 점대점(각 연결이 정확히 2개의 종단점 가짐) 방식. 멀티캐스팅 브로드캐스팅 지원 X.

연속성보다 신뢰성 있는 전송이 중요할 때 사용됨.

### UDP (User Datagram Protocol)

데이터를 데이터그램 단위로 처리하는 프로토콜.

비연결형 서비스. 연결을 위해 할당되는 논리적 경로가 없으며 각각의 패킷은 다른 경로로 전송됨. 각각의 패킷은 독립적인 관계.

정보를 주고 받을때 정보 보낸다! 받는다! 는 신호절차 X

UDP 헤더의 checksum 필드를 통해 최소한의 오류만 검출.

신뢰성 낮고 속도 빠름. 신뢰성보다는 연속성이 중요한 서비스 (ex.streaming) 에 사용됨.

### 참고

TCP/UDP는 각각 별도의 포트 주소 공간을 관리함. 같은 포트 번호 사용해도 무방함. 두 프로토콜에서 동일한 포트번호를 할당해도 서로 다른 포트로 간주.

## 웹

### HTTP, HTTPS

HTTP: 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고받을 수 있는 프로토콜. TCP, UDP를 사용하며 80번 포트를 사용한다. 비연결성, 무상태성 의 특징을 가짐.

HTTPS: HTTPS는 TCP위에 놓인 보안계층(SSL or TLS)위의 HTTP. 기본 TCP/IP 포트로 443 포트를 사용. 



### REST API





---

# 운영체제

## 프로세스

- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

- 운영체제로부터 시스템 자원을 할당받는 작업의 단위

- 할당받는 시스템 자원의 예로는 CPU시간, 주소 공간, Code/Data/Stack/Heap 구조의 독립된 메모리 영역이 있음

- 프로세스당 최소 1개의 스레드를 가지고 있음

- 각 프로세스들은 별도의 주소 공간에서 실행되기에 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음. 접근하려면 프로세스 간 통신 (IPC를 사용해야 함 - 파이프, 파일, 소켓 등 이용)

## 동기화

### Thread safe

멀티스레드 환경에서 여러 스레드가 동시에 하나의 공유 자원에 접근할 때, 의도한 대로 동작하는 것을 Thread-safe하다고 함.

Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 하고, 이를 '상호배제'라고 한다.동기화 기법으로는 Mutex나 Semaphore 등이 있음.

임계영역이란 문제의 원인이 될 수 있는 코드 블록으로, 배타적 접근 (한 순간에 하나의 쓰레드만 접근)이 요구되는 리소스에 접근하는 코드블록을 의미함.

### Reentrant

재진입성 이라는 의미로, 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미임. 해당 서브루틴에서는 공유자원을 사용하지 않으면 됨. (전역 변수 사용, 반환 하지 않고 호출 시 제공된 매개변수만으로 동작) Reentrant 하다면 Thread-safe 하지만, 역은 성립하지 않는다.

### 동기화 객체의 종류

#### 스레드 동기화 방법

- 실행 순서의 동기화: 스레드가 반드시 따라야 할 실행 순서를 정의
- 메모리 접근에 대한 동기화: 실행 순서가 중요한 것이 아니라 한 순간에 하나의 스레드만 접근하면 되는 상황을 의미

#### 동기화 기법의 종류

- 유저 모드 동기화: 커널코드가 실행되지 않는 동기화 기법으로, 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화가 있음. 성능상 이점 / 기능상 제한
  - 크리티컬 섹션의 동기화 방식은 메모리 접근 동기화에 사용한다. 열쇠를 얻은 자만이 임계영역에 들어갈 수 있다는 것.
  - 인터락 함수 기반의 동기화는 함수 내부적으로 한 순간에 하나의 쓰레드에 의에서만 실행하도록 동기화되는 것. 크리티컬 섹션 동기화 기법도 내부적으로는 인터락 함수를 기반으로 구현
- 커널 모드 동기화: 커널에서 제공하는 동기화 기능을 활용하는 방법으로, 커널 모드로의 변경이 필요하므로 성능 제한 / 다양한 기능. 뮤텍스, 세마포어, 이벤트 기반의 동기화가 있음.
  - 뮤텍스: 열쇠에 비유할 수 있는 것이 뮤텍스 오브젝트. 호출하는 과정에서 모든 초기화가 이뤄지므로 초기화 함수의 호출이 필요 없음. 
  - 세마포어: 뮤텍스와 비슷하지만 세마포어는 카운트 기능이 존재함. 임계 영역에 접근 가능한 쓰레드 갯수를 조절할 수 있음.

#### 뮤텍스와 세마포어

뮤텍스: 공유 자원 데이터에 여러 **스레드**가 접근하는 것을 막는 것. 상호배제라고 하며, 크리티컬 섹션을 가진 스레드의 running time이 겹치지 않게 단독으로 실행하게 하는 기술. 다중 프로세스들의 공유 자원에 대한 접근을 조율하기 위해 synchronized 또는 lock을 사용함. 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없음.

세마포어: 공유된 자원 데이터를 여러 **프로세스**가 접근하는 것을 막는 것. 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화시키는 기술. 리소스 상태를 나타나는 카운터로 생각할 수 있으며, 운영체제(커널)의 저장장치 내의 값임. 일반적으로 긴 시간을 확보하는 리소스에 대해 이용함. 2진수 값을 가지거나, 추가적인 값을 가질 수도 있음.

[차이점]

1. 관리하는 동기화 대상의 개수: 뮤텍스는 동기화 대상이 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용함.

2. 뮤텍스는 Binary 세마포어 (상태가 0,1뿐). 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.

3. 세마포어는 소유할 수 없지만, 뮤텍스는 소유가 가능하다.

4. 뮤텍스는 뮤텍스를 소유하고 있는 스레드만 이 뮤텍스를 해제할 수 있다. 하지만 세마포어는 아무나 세마포어를 해제할 수 있다.

## 동기 비동기

동기란? 다수의 개체들이 동일한 무언가를 가지는 것. 또는 무언가가 동일하게 되는 것. 두개의 프로세스가 데이터를 주고 받을 때 주고받는 순서(또는 시간)가 일정하다는 것을 뜻한다. 비동기는 동기가 아닌 것.

#### 동기적

어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행함. 데이터를 주고 받는 순서가 중요할 때 사용된다. 

#### 비동기적

어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다리지 않고 (작업을 위임하고) 다음 작업을 수행한다. 요청했던 작업이 끝나면 결과를 받고, 그에 따른 추가 작업이 있다면 수행한다. 요청 순서에 상관없이 동시에 다수의 작업을 처리할 수 있다는 장점이 있음.

## 교착 상태

### 교착 상태의 개념과 조건

교착상태 = 데드락

데드락이란? 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생함.

교착상태의 4가지 조건

1. 상호 배제: 공유 자원에 대한 접근 권한이 제한된다. (혹은 자원의 양이 제한되어 있을 때)

2. 점유 대기(들고 기다리기): 공유자원을 가지고 있는 프로세스가, 그 접근권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.

3. 비선점(선취 불가능): 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.

4. 순환대기: 두개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

대부분의 데드락 방지 알고리즘은 4번 조건 (사이클) 을 방지하는데에 초점이 맞춰져있다.

## context switching

현재 진행하고 있는 Task(프로세스 또는 스레드)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정.

[context switching 과정]

- Task의 대부분의 정보는 레지스터에 저장되고 PCB(Process Control Block)으로 관리된다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장한다 (Process Stack, Ready Queue)
- 다음 실행할 Task의 PCB 정보를 읽어 레지스터에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.

쓰레드의 context switching 비용이 Process의 context switching 비용보다 훨씬 저렴하다. 왜? 쓰레드는 stack 영역을 제외한 모든 메모리(code,data,heap)를 공유하기 때문에. stack 영역만 변경하면 되어서 비용이 적게 든다.

### 프로세스 동기화

### 스케줄러

### 메모리 관리 전략

### 가상 메모리

### 캐시의 지역성

### 사용자 수준 스레드와 커널 수준 스레드

### 외부 단편화 내부 단편화

### swapping





---

# 데이터베이스

참고자료: https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md

## DBMS

DBMS란? 데이터베이스를 관리하며 응용 프로그램들이 DB를 공유하며 사용할 수 있는 환경을 제공하는 소프트웨어.

- Oracle, MS_SQL, MY_SQL 등

## RDB

RDB에는 개체-관계 모델링 방법으로 데이터를 구조화한다. 중복된 데이터가 존재하면 DB를 관리하는 과정에서 이상이 생길 수 있다. 함수 종속성을 확인하면 어떤 이상이 존재할지 알 수 있으며, 함수 종속성을 없애기 위해 구조를 변경하는 작업을 정규화라고 한다.

RDB에서는

- 관계 = 테이블
- 행 = 레코드 (행의 개수: Cardinality) = 튜플
- 속성 = 컬럼 (속성의 개수: 차수 Degree) = Attribute

RDB는 관계의 집합과 제약 조건의 집합으로 이루어져있다. 제약 조건에는 키 제약 조건, 개체 무결성 제약 조건, 참조 무결성 제약 조건 등이 있다.

키는 슈퍼키, 후보키, 기본키(primary key)로 나뉜다. 후보 키는 슈퍼키 (모든 행을 유일하게 식별할 수 있도록 하는 속성의 집합) 중 가장 속성의 개수가 적은 것. 후보 키들 중 기본키는 하나. 모든 관계는 단 하나의 기본키만을 가진다. 

참조 무결성 제약 조건 = 외래 키의 대상 관계에 그 키를 가진 행이 반드시 존재해야 한다는 제약. 이 제약으로 인해 관계있는 데이터가 반드시 DB에 존재한다는 보장을 할 수 있다.

## 스키마

스키마란? DB에서 데이터의 구조, 데이터의 표현 방법, 데이터 간의 관계를 형식 언어로 정의한 구조

3단계 스키마 구조: 외부(각 사용자 관점)/개념(모든 사용자 관점)/내부 스키마 (물리적으로 DB접근)

## 무결성 제약 조건

무결성 제약 조건을 이용하면 잘못된 데이터가 DB에 입력되고 유지되는 것을 막을 수 있다. 제약조건은 SQL, 데이터 정의 언어에 의해 추가/삭제/수정된다.

대표적인 무결성 제약 조건으로는 NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK.이 있다.

## 함수적 종속성

X -> Y (X는 결정자, Y는 종속자. X가 Y를 함수적으로 결정한다. Y가 X에 함수적으로 종속되어 있다.)

X에 의해 Y가 고유하게 구분되면 X -> Y이다.

부분 함수적 종속: 속성집합 Y 가 속성집합 X 의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다.

완전 함수적 종속: 속성집합 Y가 속성집합 X 전체에 대해서만 함수적으로 종속된 경우를 말한다.

이행적 함수 종속: X,Y,Z에 대해 X->Y이고 Y->Z 이면 X->Z가 성립한다. 이때 Z가 X에 이행적으로 함수 종속되었다고 한다.

## 정규화 (Normalization)

참고 링크: https://yaboong.github.io/database/2018/03/09/database-normalization-1/

DB를 잘못 설계하면 데이터 중복으로 인한 공간낭비 + 부작용을 초래한다. 대표적 이상으로는 삽입, 갱신, 삭제 이상이 있다. RDB 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화라고 한다.

정규화를 수행하려면 속성들간의 관련성을 파악해야 하는데, 이 속성들간의 관련성을 함수적 종속성이라고 한다. 일반적으로 하나의 관계에는 하나의 함수적 종속성만이 존재하도록 정규화한다. 함수적 종속성을 이용해서 연관성 있는 속성들을 분류하고, 각 릴레이션들에서 이상현상이 생기지 않도록 하는 과정을 말한다.

- 삽입 이상 : 데이터 삽입 시 의도치않에 원하는 값들도 함께 삽입하게 되는 현상
- 삭제 이상(삭제할때 의도치 않은 값들도 함께 삭제하는 현상)
- 갱신 이상(관계의 행에 있는 속성값을 갱신할 때)

정규화로 이상들이 일어나지 않도록 할 수 있다. 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF까지 있다. 보통 3NF가 되었으면 정규화되었다고 말한다. 정규화 과정에서 주의할 점은, 정규화를 통해 분해된 릴레이션들이 조인을 통해 원래의 구조로 복원될 수 있어야 한다는 것.

1. 제 1 정규형: 테이블의 각 속성이 원자적이어야 함.
2. 제 2 정규형: 1정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**되면 제 2정규형이다.
3. 제 3 정규형: 2정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다. X->Y, Y->Z 2개의 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분해한다.

3NF를 만족하는 릴레이션의 후보키가 1개밖에 없고, 그 후보키가 기본키일 경우 항상 BCNF를 만족한다. 하지만 3정규형을 만족해도 후보키가 여러개일 경우 이상현상이 나타날 수 있다. 이를 해결하기 위한 정규형이 보이스-코드 정규형이다. (=Strong 3NF)

BCNF: X -> Y는 trival FD 이거나 (Y가 X의 부분집합), X는 릴레이션 R의 슈퍼키이다. = 즉 모든 결정자가 KEY인 경우 BCNF이다.

BCNF를 위반하는 릴레이션에 대한 정규화 과정 (분해과정) 은 다음과 같다.

- BCNF를 위반하는 nontrivial FD X -> Y를 찾는다
- 2개의 릴레이션 [XY로 구성된 릴레이션 하나, X와 나머지 속성들로 구성된 릴레이션 하나] 으로 분해한다.
- 두개의 릴레이션에서 기존 릴레이션에서 결정자 역할을 했던 속성을 키로 해준다.

## 트랜잭션

트랜잭션: 데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합

하나의 트랜잭션은 commit 되거나 rollback 된다. DBMS는 트랜잭션들의 집합으로 정의할 수 있다.

트랜잭션의 성질 (ACID):

- 원자성 (Atomicity): 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나, 전혀 수행되지 않아야 한다.

- 일관성 (Consistency): 트랜잭션 완료 후에도 DB가 일관된 상태로 유지되어야 한다.

- 독립성 (Isolation): 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때가지 다른 트랜잭션이 참조하지 못한다.

- 지속성 (Durability): 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.

트랜잭션의 상태:

![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/transaction-status.png)



트랜잭션 격리 수준 (isolation level): 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준.

ACID를 지키기 위해 Locking 개념이 등장한다. 트랜잭션이 DB를 다루는 동안 타 트랜잭션이 관여하지 못하게 막는것. 응답성과 성능 사이에서 효율적인 Locking 방법을 찾아야 한다.

1) 레벨 0: Read uncommitted - SELECT 가 수행되는 동안 해당 데이터에 shared lock이 걸리지 않는 레벨. 타 사용자가 uncommitted (=dirty) 트랜잭션 데이터인 B를 읽을 수 있다. DB의 일관성을 유지할 수 없다. 데이터 정합성에 문제가 많음.

2) 레벨 1: Read committed -  SELECT 가 수행되는 동안 해당 데이터에 shared lock이 걸리는 레벨. Commit이 이루어진 트랜잭션만 조회할 수 있다. (Dirty read 불가능) SQL server이 default로 사용하는 격리 레벨. 가장 많이 선택되는 격리 수준.

3) 레벨 2: Repeatable Read - 데이터 조회시 항상 동일한 데이터 응답을 보장하는 고립수준. 트랜잭션이 완료될 때까지 SELECT 문이 사용하는 모든 데이터에 shared lock이 걸리는 레벨. 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준. MySQL DBMS에서 기본으로 사용하며 이 격리수준에서는 NON-REPEATABLE READ 부정합이 발생하지 않음. (하나의 트랜잭션에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환)

4) 레벨 3: Serializable: 모든 작업을 하나의 트랜잭션에서 처리하는 것과 같은 높은 고립수준. 읽기 작업도 shared lock을 획득한다. 고립수준이 높은 만큼 동시성 처리효율은 떨어지지만, Phantom read를 방지할 수 있다. 하지만 거의 사용되지 않음.

격리 수준이 낮을 시 발생할 수 있는 현상:

Dirty Read: 수정중인 데이터를 다른 트랜잭션에서 보게 되는 경우

Non-Repeatable Read: 한 트랜잭션에서 같은 쿼리를 두번 이상 수행할 때 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상

Phantom Read: 한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을때 없던 레코드가 나타나는 현상.

## 쿼리 문법의 종류

- DDL(데이터 정의어): CREATE, ALTER, DROP, TRUNCATE 등 데이터베이스 스키마를 정의, 조작하는 언어

- DML(데이터 조작어): SELECT, INSERT, UPDATE, DELETE 등 데이터를 조작하기 위한 언어

- DCL(데이터 제어어): 데이터에 대한 엑세스를 제어하기 위한 언어

## Join

조인은 한 DB내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것. 조인은 테이블로 저장되거나 그 자체로 이용할 수 있는 결과 셋을 만들어냄.

조인의 종류

- 내부 조인 (inner join): 2개 테이블의 컬럼 값을 결합함으로써 새로운 결과 테이블을 생성
  - 동등 조인 (EQUI JOIN): 조인 구문에서 동등비교만을 사용
  - 자연 조인 (NATURAL JOIN): 동등 조인의 한 유형으로, 동일한 이름을 가진 컬럼의 각 쌍에 대한 하나의 컬럼만 포함
  - 교차 조인 (CROSS JOIN): 조인되는 두 테이블에서 곱집합을 반환. m행 테이블, n행 테이블이 교차조인되면 m*n개의 행 생성
- 외부 조인 (outer join): 


---



# 보안

## 대칭키 vs 비대칭키

### 대칭키 (비밀키)

- 암/복호화 키가 동일
-  대표 암호알고리즘 : DES, 3DES, TDES, AES, SEED, ARIA 등
- bit 수가 작고 수행시간이 짧다
- 사용이 제한적이다
- 디스크 암호화 등에 사용된다.

### 비대칭키 (공개키, 개인키)

- 암/복호화키가 상이하다
- 대표 암호알고리즘 : RSA, ECC 등
- bit 수가 많고 수행시간이 길다
- 비밀범호 암호화등에 사용됨
- 공개키로 암호화한것을 개인키로 복호화한다.

A와 B가 존재하고 A와 B 둘다 공개키와 비밀키를 소유하고 있다. A가 평문을 B에게 보내고자 할 때 A는 B의 공개키를 가져와 암호화하여 전달한다. B는 전달받은 암호문(B의 공개키로 암호화된 평문)을 B의 비밀키로 복호화 하여 평문을 얻는다. 반대로 B 또한 A에게 평문을 전달할 때 A의 공개키를 사용하면 된다.

## 비밀번호 암호화 방법

1. 단순 텍스트
2. 단방향 해시 함수의 다이제스트 (digest): 단방향성. 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 다이제스트를 생성. 흔히 사용하는 해시 알고리즘으로는 "SHA-256"이 있다.
3. 솔팅: 솔트란, 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열. 솔팅은 원본 메시지에 솔트를 추가하여 다이제스트를 생성하는 것이다. 사용자별로 다른 솔트를 사용하면 안식 가능성 문제가 크게 개선됨.
4. 키 스트레칭: 여러 단계의 해시 함수를 적용하여 다이제스트를 생성하는 과정.

